[{"name":"app.R","content":"library(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(tibble)\nlibrary(pracma)\n\n# Load data and model\nload(\"data/prosail_data.RData\")\nsource(\"R/reconstruction_model.R\")\n\n# Define UI\nui <- fluidPage(\n    withMathJax(),\n    titlePanel(\"Spectral Reconstruction Analysis\"),\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"sample_idx\", \"Select Sample Index:\",\n                min = 1, max = nrow(spectra_mat), value = 1, step = 1\n            ),\n            hr(),\n            h4(\"Reconstructed Parameters\"),\n            tableOutput(\"params_table\"),\n            hr(),\n            helpText(\"Adjust the slider to view different samples from the PROSAIL dataset.\")\n        ),\n        mainPanel(\n            tabsetPanel(\n                tabPanel(\n                    \"Visualisation\",\n                    plotOutput(\"main_plot\", height = \"500px\"),\n                    h4(\"Model Performance\"),\n                    verbatimTextOutput(\"metrics\")\n                ),\n                tabPanel(\n                    \"Error Analysis\",\n                    plotOutput(\"error_plot\", height = \"500px\")\n                ),\n                tabPanel(\n                    \"Equations\",\n                    h3(\"Mathematical Model\"),\n                    p(\"The spectrum is reconstructed using a piecewise approach with three segments:\"),\n                    h4(\"1. Visible Region (400 - 680 nm)\"),\n                    p(\"Modeled as a linear baseline minus two Gaussian absorption features (Chlorophyll at 670nm and Blue absorption at 450nm).\"),\n                    uiOutput(\"eq_vis\"),\n                    h4(\"2. Red Edge (680 - 780 nm)\"),\n                    p(\"Modeled using a 4-parameter logistic function.\"),\n                    uiOutput(\"eq_re\"),\n                    h4(\"3. NIR Plateau (780 - 1100 nm)\"),\n                    p(\"Modeled as a linear baseline minus a Gaussian water absorption feature at 980nm.\"),\n                    uiOutput(\"eq_nir\")\n                )\n            )\n        )\n    )\n)\n\n# Define Server\nserver <- function(input, output) {\n    # Reactive reconstruction\n    reconstruction <- reactive({\n        idx <- input$sample_idx\n        obs_spectrum <- spectra_mat[idx, ]\n\n        # Create named vector for the function\n        names(obs_spectrum) <- paste0(\"R\", wavelengths)\n\n        # Reconstruct\n        res <- reconstruct_spec_parametric(obs_spectrum, wavelengths)\n\n        list(\n            obs = obs_spectrum,\n            rec = res$spectrum,\n            features = res$features\n        )\n    })\n\n    # Main Plot\n    output$main_plot <- renderPlot({\n        data <- reconstruction()\n\n        df <- data.frame(\n            Wavelength = wavelengths,\n            Reflectance = as.numeric(data$obs),\n            Type = \"Reference\"\n        )\n\n        df_rec <- data.frame(\n            Wavelength = wavelengths,\n            Reflectance = data$rec,\n            Type = \"Reconstructed\"\n        )\n\n        plot_df <- rbind(df, df_rec)\n\n        ggplot(plot_df, aes(x = Wavelength, y = Reflectance, color = Type)) +\n            geom_line(size = 1) +\n            scale_color_manual(values = c(\"Reference\" = \"black\", \"Reconstructed\" = \"red\")) +\n            theme_minimal() +\n            labs(\n                title = paste(\"Sample\", input$sample_idx, \"- Reference vs Reconstruction\"),\n                y = \"Reflectance\", x = \"Wavelength (nm)\"\n            ) +\n            theme(legend.position = \"top\", text = element_text(size = 14))\n    })\n\n    # Error Plot\n    output$error_plot <- renderPlot({\n        data <- reconstruction()\n\n        error <- data$rec - as.numeric(data$obs)\n\n        df_err <- data.frame(\n            Wavelength = wavelengths,\n            Error = error\n        )\n\n        ggplot(df_err, aes(x = Wavelength, y = Error)) +\n            geom_line(color = \"blue\", size = 1) +\n            geom_hline(yintercept = 0, linetype = \"dashed\", color = \"gray\") +\n            theme_minimal() +\n            labs(\n                title = \"Reconstruction Error (Reconstructed - Reference)\",\n                y = \"Error\", x = \"Wavelength (nm)\"\n            ) +\n            theme(text = element_text(size = 14))\n    })\n\n    # Parameters Table\n    output$params_table <- renderTable(\n        {\n            feats <- reconstruction()$features\n\n            data.frame(\n                Parameter = c(\n                    \"A (Chl)\", \"Sigma (Chl)\",\n                    \"Lambda_i\", \"C (Slope)\", \"AUC (NIR)\"\n                ),\n                Value = sprintf(\"%.4f\", c(\n                    feats$A, feats$sigma,\n                    feats$lambda_i, feats$C, feats$AUC\n                ))\n            )\n        },\n        colnames = FALSE\n    )\n\n    # Metrics\n    output$metrics <- renderText({\n        data <- reconstruction()\n        rmse <- sqrt(mean((data$rec - as.numeric(data$obs))^2))\n        paste(\"RMSE:\", round(rmse, 5))\n    })\n\n    # Equations\n    output$eq_vis <- renderUI({\n        withMathJax(\n            \"$$ R_{vis}(\\\\lambda) = R_{base}(\\\\lambda) - A \\\\cdot \\\\exp\\\\left(-\\\\frac{(\\\\lambda - 670)^2}{2\\\\sigma^2}\\\\right) - A_{blue} \\\\cdot \\\\exp\\\\left(-\\\\frac{(\\\\lambda - 450)^2}{2\\\\sigma_{blue}^2}\\\\right) $$\"\n        )\n    })\n\n    output$eq_re <- renderUI({\n        withMathJax(\n            \"$$ R_{re}(\\\\lambda) = R_{min} + \\\\frac{R_{max} - R_{min}}{1 + \\\\exp(C(\\\\lambda_i - \\\\lambda))} $$\"\n        )\n    })\n\n    output$eq_nir <- renderUI({\n        withMathJax(\n            \"$$ R_{nir}(\\\\lambda) = R_{nir\\\\_base}(\\\\lambda) - A_{water} \\\\cdot \\\\exp\\\\left(-\\\\frac{(\\\\lambda - 980)^2}{2\\\\sigma_{water}^2}\\\\right) $$\"\n        )\n    })\n}\n\n# Run the application\nshinyApp(ui = ui, server = server)\n","type":"text"},{"name":"R/reconstruction_model.R","content":"library(pracma)\n\n# --- Helper Functions ---\n\n# Guyot & Baret Formula for Inflection Point\ncalc_lambda_i <- function(r670, r700, r740, r780) {\n  rho_i <- (r670 + r780) / 2\n  denom <- r740 - r700\n  if (abs(denom) < 1e-6) denom <- ifelse(denom < 0, -1, 1) * 1e-6\n  700 + 40 * ((rho_i - r700) / denom)\n}\n\n# Logistic Function\npredict_logistic <- function(lambda, C, r_min, r_max, lambda_i) {\n  r_min + (r_max - r_min) / (1 + exp(C * (lambda_i - lambda)))\n}\n\n# --- Main Reconstruction Function ---\n\nreconstruct_spec_parametric <- function(obs_r, wl) {\n  # Define required anchor bands\n  # We need: 400 (base), 550 (green), 670 (red min), 700, 740, 750 (base end), 780 (nir start), 980 (water), 1100 (nir end)\n  target_bands <- c(400, 550, 670, 700, 740, 750, 780, 980, 1100)\n  \n  # Find indices (nearest neighbor if exact match missing)\n  idx <- vapply(target_bands, function(t) which.min(abs(wl - t)), integer(1))\n  r_anchors <- obs_r[idx]\n  names(r_anchors) <- paste0(\"R\", target_bands)\n  \n  # --- Segment 1: Visible (400 - 680 nm) ---\n  # Model: Inverted Gaussian on Linear Baseline\n  # Baseline connects R400 and R750 (as per instructions)\n  \n  slope_base <- (r_anchors[\"R750\"] - r_anchors[\"R400\"]) / (750 - 400)\n  intercept_base <- r_anchors[\"R400\"] - slope_base * 400\n  calc_baseline <- function(l) slope_base * l + intercept_base\n  \n  mu <- 670 # Fixed center of absorption\n  \n  # Calculate Amplitude (A) at 670nm\n  # R_obs(670) = Baseline(670) - A  =>  A = Baseline(670) - R_obs(670)\n  base_670 <- calc_baseline(670)\n  A <- base_670 - r_anchors[\"R670\"]\n  \n  # Calculate Sigma at 550nm\n  # R_obs(550) = Baseline(550) - A * exp(...)\n  base_550 <- calc_baseline(550)\n  delta_550 <- base_550 - r_anchors[\"R550\"]\n  \n  # Solve for sigma: ratio = delta / A = exp(...)\n  ratio <- delta_550 / A\n  \n  # Safety checks for log\n  if (is.na(ratio) || ratio <= 0 || ratio >= 1) {\n    sigma <- 40 # Fallback width\n  } else {\n    # ratio = exp( - (550-670)^2 / 2sigma^2 )\n    # ln(ratio) = - (120)^2 / 2sigma^2\n    # sigma^2 = - (120)^2 / (2 * ln(ratio))\n    sigma <- sqrt( - (550 - 670)^2 / (2 * log(ratio)) )\n  }\n  \n  vis_fun <- function(l) {\n    calc_baseline(l) - A * exp( - (l - mu)^2 / (2 * sigma^2) )\n  }\n  \n  # --- Segment 2: Red Edge (680 - 780 nm) ---\n  # Model: 4-Parameter Logistic\n  \n  lambda_i <- calc_lambda_i(r_anchors[\"R670\"], r_anchors[\"R700\"], r_anchors[\"R740\"], r_anchors[\"R780\"])\n  \n  # Optimize C to fit R700 and R740\n  rss_logistic <- function(C) {\n    preds <- predict_logistic(c(700, 740), C, r_anchors[\"R670\"], r_anchors[\"R780\"], lambda_i)\n    sum((preds - c(r_anchors[\"R700\"], r_anchors[\"R740\"]))^2)\n  }\n  \n  opt_res <- optim(0.05, rss_logistic, method=\"L-BFGS-B\", lower=0.001, upper=2.0)\n  C_opt <- opt_res$par\n  \n  re_fun <- function(l) {\n    predict_logistic(l, C_opt, r_anchors[\"R670\"], r_anchors[\"R780\"], lambda_i)\n  }\n  \n  # --- Segment 3: NIR Plateau (780 - 1100 nm) ---\n  # Model: Quadratic Polynomial (ax^2 + bx + c)\n  # Constrained by R780, R980, R1100\n  \n  nir_x <- c(780, 980, 1100)\n  nir_y <- c(r_anchors[\"R780\"], r_anchors[\"R980\"], r_anchors[\"R1100\"])\n  \n  # Solve system of linear equations for a, b, c\n  X_mat <- cbind(nir_x^2, nir_x, 1)\n  coeffs <- tryCatch(solve(X_mat, nir_y), error = function(e) c(0, 0, mean(nir_y)))\n  a_nir <- coeffs[1]\n  b_nir <- coeffs[2]\n  c_nir <- coeffs[3]\n  \n  nir_fun <- function(l) {\n    a_nir * l^2 + b_nir * l + c_nir\n  }\n  \n  # --- Feature: AUC (780 - 1000 nm) ---\n  # Integral of quadratic: (a/3)x^3 + (b/2)x^2 + cx\n  auc_integ <- function(l) (a_nir/3)*l^3 + (b_nir/2)*l^2 + c_nir*l\n  auc_val <- auc_integ(1000) - auc_integ(780)\n  \n  # --- Construct Full Spectrum ---\n  rec_spec <- numeric(length(wl))\n  \n  mask_vis <- wl <= 680\n  rec_spec[mask_vis] <- vis_fun(wl[mask_vis])\n  \n  mask_re <- wl > 680 & wl <= 780\n  rec_spec[mask_re] <- re_fun(wl[mask_re])\n  \n  mask_nir <- wl > 780\n  rec_spec[mask_nir] <- nir_fun(wl[mask_nir])\n  \n  list(\n    spectrum = rec_spec,\n    features = list(\n      A = A,\n      sigma = sigma,\n      lambda_i = lambda_i,\n      C = C_opt,\n      a_nir = a_nir,\n      AUC = auc_val\n    )\n  )\n}\n","type":"text"}]
